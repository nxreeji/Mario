/** @file Player.cpp
 * @brief Реализация класса Player, управляющего поведением игрока, включая движение, прыжки и взаимодействие с уровнем.
 * @author AnastaVensk
 */

#include "Player.hpp" /**< Подключает заголовочный файл Player.hpp с объявлением класса Player. */
#include "Utils.hpp" /**< Подключает заголовочный файл Utils.hpp для функции логирования getCurrentTime. */
#include <ncurses.h> /**< Подключает библиотеку ncurses для работы с консольным интерфейсом. */
#include <fstream> /**< Подключает библиотеку для работы с файлами (логирование). */
#include <cmath> /**< Подключает библиотеку для математических функций, таких как std::abs. */

/** @brief Внешняя переменная debugLog для записи логов в файл debug.log.
 * @author AnastaVensk
 */
extern std::ofstream debugLog;

/** @brief Конструктор класса Player, инициализирует игрока с заданными параметрами.
 * @param x Начальная координата X игрока.
 * @param y Начальная координата Y игрока.
 * @param type Тип игрока (например, "Player").
 * @param difficulty Уровень сложности (0 = лёгкий, 1 = средний, 2 = сложный).
 * @author AnastaVensk
 */
Player::Player(float x, float y, const std::string& type, int difficulty) 
    : x(x), y(y), velocityX(0), velocityY(0), onGround(false), 
      moveLeft(false), moveRight(false), jumpRequested(false), 
      lives(3 + (2 - difficulty)), score(0), type(type), 
      invulnerabilityTimer(0), difficulty(difficulty) { /**< Инициализирует члены класса начальными значениями. */
    debugLog << "[" << getCurrentTime() << "] Игрок создан: x=" << x << "\ty=" << y << "\tжизни=" << lives << "\n"; /**< Логирует создание игрока с координатами и количеством жизней. */
} /**< Завершает конструктор Player. */

/** @brief Устанавливает запрос на прыжок и выполняет его, если игрок на земле.
 * @param jump Флаг, указывающий, запрошен ли прыжок.
 * @author AnastaVensk
 */
void Player::setJump(bool jump) { /**< Объявляет метод для обработки запроса на прыжок. */
    jumpRequested = jump; /**< Сохраняет флаг запроса на прыжок. */
    if (jump && onGround) { /**< Проверяет, запрошен ли прыжок и находится ли игрок на земле. */
        velocityY = -10.0f; /**< Устанавливает вертикальную скорость для прыжка (вверх). */
        onGround = false; /**< Отмечает, что игрок больше не на земле. */
        debugLog << "[" << getCurrentTime() << "] Прыжок выполнен: velocityY=" << velocityY << "\n"; /**< Логирует выполнение прыжка с текущей скоростью. */
    } /**< Завершает обработку прыжка. */
} /**< Завершает метод setJump. */

/** @brief Сбрасывает все флаги движения игрока.
 * @author AnastaVensk
 */
void Player::resetMovement() { /**< Объявляет метод для сброса движения. */
    moveLeft = false; /**< Отключает движение влево. */
    moveRight = false; /**< Отключает движение вправо. */
    jumpRequested = false; /**< Сбрасывает запрос на прыжок. */
    debugLog << "[" << getCurrentTime() << "] Движение сброшено\n"; /**< Логирует сброс движения. */
} /**< Завершает метод resetMovement. */

/** @brief Обновляет состояние игрока, включая движение, физику и взаимодействие с уровнем.
 * @param level Ссылка на объект уровня для проверки коллизий и взаимодействий.
 * @param deltaTime Время, прошедшее с последнего кадра, для плавного движения.
 * @author AnastaVensk
 */
void Player::update(Level& level, float deltaTime) { /**< Объявляет метод обновления состояния игрока. */
    if (invulnerabilityTimer > 0) { /**< Проверяет, активен ли таймер неуязвимости. */
        invulnerabilityTimer -= deltaTime; /**< Уменьшает таймер неуязвимости на время кадра. */
        debugLog << "[" << getCurrentTime() << "] Неуязвимость: таймер=" << invulnerabilityTimer << "\n"; /**< Логирует текущее значение таймера неуязвимости. */
    } /**< Завершает обработку таймера неуязвимости. */

    if (!onGround) { /**< Проверяет, находится ли игрок в воздухе. */
        velocityY += 20.0f * deltaTime; /**< Применяет гравитацию, увеличивая вертикальную скорость вниз. */
    } /**< Завершает обработку гравитации. */

    velocityX = 0; /**< Сбрасывает горизонтальную скорость перед обработкой ввода. */
    if (moveLeft && !moveRight) { /**< Проверяет, активен ли ввод для движения влево без движения вправо. */
        velocityX = -5.0f; /**< Устанавливает скорость влево. */
        debugLog << "[" << getCurrentTime() << "] Движение влево: velocityX=" << velocityX << "\n"; /**< Логирует движение влево с текущей скоростью. */
    } else if (moveRight && !moveLeft) { /**< Проверяет, активен ли ввод для движения вправо без движения влево. */
        velocityX = 5.0f; /**< Устанавливает скорость вправо. */
        debugLog << "[" << getCurrentTime() << "] Движение вправо: velocityX=" << velocityX << "\n"; /**< Логирует движение вправо с текущей скоростью. */
    } /**< Завершает обработку горизонтального движения. */

    float newX = x + velocityX * deltaTime; /**< Вычисляет новую координату X с учётом скорости и времени. */
    float newY = y + velocityY * deltaTime; /**< Вычисляет новую координату Y с учётом скорости и времени. */

    int checkY = static_cast<int>(newY + (velocityY > 0 ? 0.9f : 0.0f)); /**< Вычисляет Y-координату для проверки коллизии, добавляя смещение при падении. */
    if (checkY >= 0 && checkY < level.getHeight() && 
        level.getTile(static_cast<int>(newX), checkY) != TileType::WALL) { /**< Проверяет, находится ли новая позиция Y в пределах уровня и не сталкивается со стеной. */
        y = newY; /**< Обновляет координату Y игрока. */
    } else { /**< Обрабатывает столкновение по вертикали. */
        if (velocityY > 0) { /**< Проверяет, падает ли игрок (скорость вниз). */
            y = static_cast<int>(newY); /**< Округляет Y-координату до ближайшей клетки. */
            velocityY = 0; /**< Сбрасывает вертикальную скорость. */
            onGround = true; /**< Отмечает, что игрок на земле. */
            debugLog << "[" << getCurrentTime() << "] Игрок на земле: y=" << y << "\n"; /**< Логирует приземление игрока. */
        } else if (velocityY < 0) { /**< Проверяет, прыгает ли игрок (скорость вверх). */
            y = static_cast<int>(newY + 1); /**< Округляет Y-координату, учитывая столкновение с потолком. */
            velocityY = 0; /**< Сбрасывает вертикальную скорость. */
            debugLog << "[" << getCurrentTime() << "] Коллизия сверху: y=" << y << "\n"; /**< Логирует столкновение с потолком. */
        } /**< Завершает обработку вертикальных коллизий. */
    } /**< Завершает проверку вертикального движения. */

    int checkX = static_cast<int>(newX + (velocityX > 0 ? 0.9f : 0.0f)); /**< Вычисляет X-координату для проверки коллизии, добавля добавляя смещение при движении вправо. */
    if (checkX >= 0 && checkX < level.getWidth() && 
        level.getTile(checkX, static_cast<int>(y)) != TileType::WALL) { /**< Проверяет, находится ли новая позиция X в пределах уровня и не сталкивается со стеной. */
        x = newX; /**< Обновляет координату X игрока. */
    } else { /**< Обрабатывает столкновение по горизонтали. */
        debugLog << "[" << getCurrentTime() << "] Коллизия по горизонтали: x=" << newX << "\ty=" << y << "\tcheckX=" << checkX << "\ttile=" << static_cast<int>(level.getTile(checkX, static_cast<int>(y))) << "\n"; /**< Логирует горизонтальное столкновение с деталями. */
        velocityX = 0; /**< Сбрасывает горизонтальную скорость. */
    } /**< Завершает проверку горизонтального движения. */

    int tileX = static_cast<int>(x); /**< Преобразует текущую X-координату в целую для проверки клетки. */
    int tileY = static_cast<int>(y); /**< Преобразует текущую Y-координату в целую для проверки клетки. */
    if (level.getTile(tileX, tileY) == TileType::COIN) { /**< Проверяет, находится ли игрок на клетке с монетой. */
        score += 10; /**< Увеличивает счёт игрока на 10 за монету. */
        level.setTile(tileX, tileY, TileType::EMPTY); /**< Удаляет монету, заменяя клетку на пустую. */
        debugLog << "[" << getCurrentTime() << "] Монета собрана, очки: " << score << "\n"; /**< Логирует сбор монеты и текущий счёт. */
    } else if (level.getTile(tileX, tileY) == TileType::FINISH) { /**< Проверяет, достиг ли игрок финиша. */
        debugLog << "[" << getCurrentTime() << "] Финиш достигнут: x=" << x << "\ty=" << y << "\n"; /**< Логирует достижение финиша. */
        throw std::runtime_error("Победа: финиш достигнут!"); /**< Выбрасывает исключение для завершения игры с победой. */
    } else if (level.getTile(tileX, tileY) == TileType::SPIKES) { /**< Проверяет, попал ли игрок на шипы. */
        debugLog << "[" << getCurrentTime() << "] Игрок попал на шипы: x=" << x << "\ty=" << y << "\n"; /**< Логирует попадание на шипы. */
        throw std::runtime_error("Игра окончена: игрок попал на шипы!"); /**< Выбрасывает исключение для завершения игры из-за шипов. */
    } /**< Завершает проверку взаимодействия с клетками. */

    debugLog << "[" << getCurrentTime() << "] Позиция игрока: x=" << x << "\ty=" << y << "\n"; /**< Логирует текущую позицию игрока. */
} /**< Завершает метод update. */