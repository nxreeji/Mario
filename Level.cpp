/** @file Level.cpp
 * @brief Реализация класса Level, управляющего загрузкой и взаимодействием с картой уровня.
 * @author akonch
 */

#include "Level.hpp" /**< Подключает заголовочный файл Level.hpp с объявлением класса Level. */
#include "Game.hpp" /**< Подключает заголовочный файл Game.hpp для взаимодействия с игрой. */
#include "Utils.hpp" /**< Подключает заголовочный файл Utils.hpp для функции логирования getCurrentTime(). */
#include <fstream> /**< Подключает библиотеку для работы с файлами (чтение карты). */
#include <stdexcept> /**< Подключает библиотеку для обработки исключений (std::runtime_error). */
#include <sstream> /**< Подключает библиотеку для работы со строковыми потоками (форматирование ошибок). */

/** @brief Внешняя глобальная переменная debugLog для записи логов в файл debug.log.
 * @author akonch
 */
extern std::ofstream debugLog;

/** @brief Конструктор класса Level, инициализирует пустой уровень.
 * @author akonch
 */
Level::Level() : width(0), height(0), playerStartX(0), playerStartY(0) { /**< Инициализирует размеры уровня и начальные координаты игрока нулями. */
} /**< Завершает конструктор Level. */

/** @brief Загружает уровень из файла, инициализируя карту и позиции объектов.
 * @param filename Имя файла карты (например, "map.txt").
 * @param game Ссылка на объект игры для передачи данных.
 * @param difficulty Уровень сложности (влияет на другие классы).
 * @author akonch
 */
void Level::loadFromFile(const std::string& filename, Game& game, int difficulty) { /**< Объявляет метод загрузки уровня из файла. */
    std::ifstream file(filename); /**< Открывает файл карты для чтения. */
    if (!file.is_open()) { /**< Проверяет, удалось ли открыть файл. */
        throw std::runtime_error("Не удалось открыть файл карты: " + filename); /**< Выбрасывает исключение, если файл не открыт. */
    } /**< Завершает проверку открытия файла. */

    std::vector<std::string> lines; /**< Создаёт вектор для хранения строк карты. */
    std::string line; /**< Создаёт строку для чтения данных из файла. */
    while (std::getline(file, line)) { /**< Читает файл построчно. */
        if (!line.empty() && line.back() == '\r') { /**< Проверяет, есть ли символ возврата каретки (\r) в конце строки. */
            line.pop_back(); /**< Удаляет символ \r из конца строки. */
        } /**< Завершает обработку символа \r. */
        if (!line.empty()) { /**< Проверяет, не является ли строка пустой после обработки. */
            lines.push_back(line); /**< Добавляет строку в вектор строк карты. */
        } /**< Завершает проверку пустой строки. */
    } /**< Завершает цикл чтения файла. */
    file.close(); /**< Закрывает файл карты. */

    if (lines.empty()) { /**< Проверяет, не является ли карта пустой. */
        throw std::runtime_error("Файл карты пуст: " + filename); /**< Выбрасывает исключение, если файл пуст. */
    } /**< Завершает проверку пустоты карты. */

    height = lines.size(); /**< Устанавливает высоту уровня как количество строк. */
    width = lines[0].size(); /**< Устанавливает ширину уровня как длину первой строки. */
    tiles.assign(height, std::vector<TileType>(width, TileType::EMPTY)); /**< Инициализирует карту уровня пустыми клетками. */
    enemyPositions.clear(); /**< Очищает вектор позиций врагов перед заполнением. */

    for (size_t y = 0; y < height; ++y) { /**< Перебирает строки карты для обработки. */
        if (lines[y].size() != width) { /**< Проверяет, совпадает ли длина строки с шириной уровня. */
            throw std::runtime_error("Неверный формат карты: неравная длина строк"); /**< Выбрасывает исключение при неравной длине строк. */
        } /**< Завершает проверку длины строки. */
        for (size_t x = 0; x < width; ++x) { /**< Перебирает символы в строке для обработки клеток. */
            char c = lines[y][x]; /**< Получает текущий символ из строки карты. */
            switch (c) { /**< Начинает обработку символа карты. */
                case '#': /**< Проверяет символ стены. */
                    tiles[y][x] = TileType::WALL; /**< Устанавливает клетку как стену. */
                    break; /**< Завершает обработку стены. */
                case 'C': /**< Проверяет символ монеты. */
                    tiles[y][x