/** @file Game.cpp
 * @brief Реализация класса Game, управляющего основной логикой игры, включая инициализацию, ввод, обновление и рендеринг.
 * @author H0ly
 */

#include "Game.hpp" /**< Подключает заголовочный файл Game.hpp, содержащий объявление класса Game. */
#include "Level.hpp" /**< Подключает заголовочный файл Level.hpp для работы с уровнем. */
#include "Player.hpp" /**< Подключает заголовочный файл Player.hpp для работы с игроком. */
#include "Enemy.hpp" /**< Подключает заголовочный файл Enemy.hpp для работы с врагами. */
#include "Utils.hpp" /**< Подключает заголовочный файл Utils.hpp для вспомогательных функций, таких как логирование. */
#include <ncurses.h> /**< Подключает библиотеку ncurses для работы с консольным интерфейсом. */
#include <fstream> /**< Подключает библиотеку для работы с файлами (используется для логирования). */
#include <cmath> /**< Подключает библиотеку для математических функций, таких как std::abs. */
#include <stdexcept> /**< Подключает библиотеку для обработки исключений (std::runtime_error). */

/** @brief Внешняя переменная debugLog для записи логов в файл debug.log.
 * @author H0ly
 */
extern std::ofstream debugLog;

/** @brief Конструктор класса Game, инициализирует ncurses и игровые параметры.
 * @author H0ly
 */
Game::Game() : screenWidth(0), screenHeight(0), cameraX(0), cameraY(0) { /**< Инициализирует ширину/высоту экрана и позицию камеры нулями. */
    initscr(); /**< Инициализирует библиотеку ncurses для работы с консолью. */
    start_color(); /**< Включает поддержку цветов в ncurses. */
    cbreak(); /**< Включает режим cbreak (немедленная обработка ввода без ожидания Enter). */
    noecho(); /**< Отключает отображение вводимых символов в консоли. */
    keypad(stdscr, TRUE); /**< Включает поддержку специальных клавиш (стрелки, Esc и т.д.). */
    nodelay(stdscr, TRUE); /**< Устанавливает неблокирующий режим ввода (getch не ждёт нажатия). */
    curs_set(0); /**< Скрывает курсор в консоли. */

    init_pair(1, COLOR_WHITE, COLOR_BLACK); /**< Задаёт цветовую пару 1: белый текст на чёрном фоне для стен. */
    init_pair(2, COLOR_YELLOW, COLOR_BLACK); /**< Задаёт цветовую пару 2: жёлтый текст на чёрном фоне для монет. */
    init_pair(3, COLOR_GREEN, COLOR_BLACK); /**< Задаёт цветовую пару 3: зелёный текст на чёрном фоне для финиша. */
    init_pair(4, COLOR_CYAN, COLOR_BLACK); /**< Задаёт цветовую пару 4: голубой текст на чёрном фоне для игрока. */
    init_pair(5, COLOR_RED, COLOR_BLACK); /**< Задаёт цветовую пару 5: красный текст на чёрном фоне для врагов. */
    init_pair(6, COLOR_MAGENTA, COLOR_BLACK); /**< Задаёт цветовую пару 6: пурпурный текст на чёрном фоне для шипов. */

    getmaxyx(stdscr, screenHeight, screenWidth); /**< Получает текущие размеры окна консоли и сохраняет их в screenHeight и screenWidth. */
    debugLog << "[" << getCurrentTime() << "] Инициализация экрана: ширина=" << screenWidth << "\tвысота=" << screenHeight << "\n"; /**< Логирует размеры экрана и время инициализации. */

    level = std::make_unique<Level>(); /**< Создаёт новый уровень, используя умный указатель unique_ptr. */
} /**< Завершает конструктор Game. */

/** @brief Деструктор класса Game, завершает работу ncurses.
 * @author H0ly
 */
Game::~Game() { /**< Объявляет деструктор класса Game. */
    endwin(); /**< Завершает работу ncurses, возвращая консоль в нормальный режим. */
} /**< Завершает деструктор Game. */

/** @brief Настраивает уровень, загружая карту и инициализируя игрока и врагов.
 * @param difficulty Уровень сложности (0 = лёгкий, 1 = средний, 2 = сложный).
 * @author H0ly
 */
void Game::setupLevel(int difficulty) { /**< Объявляет метод для настройки уровня с заданной сложностью. */
    try { /**< Начинает блок обработки исключений для загрузки уровня. */
        level->loadFromFile("map.txt", *this, difficulty); /**< Загружает карту из файла map.txt, передавая текущий объект Game и сложность. */
        player = std::make_unique<Player>(level->getPlayerStartX(), level->getPlayerStartY(), "Player", difficulty); /**< Создаёт игрока в начальной позиции с заданной сложностью. */
        enemies.clear(); /**< Очищает вектор врагов перед добавлением новых. */
        for (const auto& pos : level->getEnemyPositions()) { /**< Перебирает позиции врагов, полученные из уровня. */
            enemies.push_back(std::make_unique<Enemy>(pos.first, pos.second, difficulty)); /**< Создаёт нового врага в указанной позиции и добавляет его в вектор. */
        } /**< Завершает цикл перебора позиций врагов. */
    } catch (const std::runtime_error& e) { /**< Ловит исключения, возникшие при загрузке уровня. */
        debugLog << "[" << getCurrentTime() << "] Ошибка загрузки уровня: " << e.what() << "\n"; /**< Логирует ошибку с описанием и временем. */
        throw; /**< Перебрасывает исключение для обработки на верхнем уровне. */
    } /**< Завершает блок обработки исключений. */
} /**< Завершает метод setupLevel. */

/** @brief Основной игровой цикл, обрабатывающий ввод, обновление и рендеринг.
 * @author H0ly
 */
void Game::runGame() { /**< Объявляет метод для запуска игрового цикла. */
    bool pause = false; /**< Флаг паузы, изначально выключен. */
    auto lastTime = std::chrono::high_resolution_clock::now(); /**< Фиксирует текущее время для вычисления времени кадра. */

    while (true) { /**< Запускает бесконечный игровой цикл. */
        auto currentTime = std::chrono::high_resolution_clock::now(); /**< Получает текущее время для расчёта deltaTime. */
        float deltaTime = std::chrono::duration<float>(currentTime - lastTime).count(); /**< Вычисляет время, прошедшее с последнего кадра. */
        lastTime = currentTime; /**< Обновляет время последнего кадра. */

        int key = getch(); /**< Считывает нажатую клавишу (или ERR, если клавиша не нажата). */
        handleInput(key, pause); /**< Обрабатывает ввод пользователя, обновляя состояние паузы. */

        if (!pause) { /**< Проверяет, не находится ли игра на паузе. */
            try { /**< Начинает блок обработки исключений для обновления игровых объектов. */
                player->update(*level, deltaTime); /**< Обновляет состояние игрока с учётом уровня и времени кадра. */
                for (auto& enemy : enemies) { /**< Перебирает всех врагов в векторе. */
                    enemy->update(*level, deltaTime); /**< Обновляет состояние каждого врага. */
                } /**< Завершает цикл обновления врагов. */
                if (player->getInvulnerabilityTimer() <= 0) { /**< Проверяет, не активен ли таймер неуязвимости игрока. */
                    for (const auto& enemy : enemies) { /**< Перебирает врагов для проверки столкновений. */
                        if (std::abs(enemy->getX() - player->getX()) < 0.5f && /**< Проверяет близость игрока и врага по X. */
                            std::abs(enemy->getY() - player->getY()) < 0.5f) { /**< Проверяет близость игрока и врага по Y. */
                            player->takeDamage(); /**< Наносит урон игроку при столкновении. */
                            debugLog << "[" << getCurrentTime() << "] Столкновение с врагом, жизни: " << player->getLives() << "\n"; /**< Логирует столкновение и текущее количество жизней. */
                            if (player->getLives() <= 0) { /**< Проверяет, закончились ли жизни игрока. */
                                debugLog << "[" << getCurrentTime() << "] Игра окончена: жизни кончились\n"; /**< Логирует конец игры из-за потери жизней. */
                                throw std::runtime_error("Игра окончена: жизни кончились"); /**< Выбрасывает исключение для завершения игры. */
                            } /**< Завершает проверку жизней. */
                        } /**< Завершает проверку столкновения с врагом. */
                    } /**< Завершает цикл проверки столкновений. */
                } /**< Завершает проверку неуязвимости. */
            } catch (const std::runtime_error& e) { /**< Ловит исключения, возникшие при обновлении. */
                debugLog << "[" << getCurrentTime() << "] Игра окончена: " << e.what() << "\n"; /**< Логирует причину завершения игры. */
                break; /**< Выходит из игрового цикла. */
            } /**< Завершает блок обработки исключений. */
        } /**< Завершает блок обновления при отсутствии паузы. */

        render(); /**< Вызывает метод рендеринга для отрисовки сцены. */
        napms(16); /**< Задерживает цикл на ~16 мс для ограничения частоты кадров (~60 FPS). */
    } /**< Завершает игровой цикл. */
} /**< Завершает метод runGame. */

/** @brief Обрабатывает ввод пользователя и обновляет состояние игры.
 * @param key Код нажатой клавиши (или ERR, если клавиша не нажата).
 * @param pause Ссылка на флаг паузы, который может быть изменён.
 * @author H0ly
 */
void Game::handleInput(int key, bool& pause) { /**< Объявляет метод обработки ввода. */
    bool prevLeft = keyStates['a'] || keyStates[KEY_LEFT]; /**< Сохраняет предыдущее состояние клавиш влево ('a' или стрелка). */
    bool prevRight = keyStates['d'] || keyStates[KEY_RIGHT]; /**< Сохраняет предыдущее состояние клавиш вправо ('d' или стрелка). */

    if (key == ERR) { /**< Проверяет, не было ли ввода (ERR означает отсутствие нажатия). */
        if (prevLeft && !keyStates['a'] && !keyStates[KEY_LEFT]) { /**< Проверяет, было ли движение влево, но клавиши отпущены. */
            keyStates['a'] = false; /**< Сбрасывает состояние клавиши 'a'. */
            keyStates[KEY_LEFT] = false; /**< Сбрасывает состояние клавиши стрелки влево. */
            player->setMoveLeft(false); /**< Отключает движение игрока влево. */
            debugLog << "[" << getCurrentTime() << "] Движение влево остановлено (ERR)\n"; /**< Логирует остановку движения влево. */
        } /**< Завершает обработку остановки движения влево. */
        if (prevRight && !keyStates['d'] && !keyStates[KEY_RIGHT]) { /**< Проверяет, было ли движение вправо, но клавиши отпущены. */
            keyStates['d'] = false; /**< Сбрасывает состояние клавиши 'd'. */
            keyStates[KEY_RIGHT] = false; /**< Сбрасывает состояние клавиши стрелки вправо. */
            player->setMoveRight(false); /**< Отключает движение игрока вправо. */
            debugLog << "[" << getCurrentTime() << "] Движение вправо остановлено (ERR)\n"; /**< Логирует остановку движения вправо. */
        } /**< Завершает обработку остановки движения вправо. */
        return; /**< Завершает метод, если не было ввода. */
    } /**< Завершает обработку отсутствия ввода. */

    debugLog << "[" << getCurrentTime() << "] Нажата клавиша (код): " << key << "\n"; /**< Логирует код нажатой клавиши и время. */

    bool keyProcessed = false; /**< Флаг, указывающий, была ли клавиша обработана. */
    switch (key) { /**< Начинает обработку нажатой клавиши. */
        case 27: /**< Проверяет нажатие клавиши Esc (код 27). */
            pause = true; /**< Устанавливает флаг паузы в true. */
            debugLog << "[" << getCurrentTime() << "] Нажата клавиша Esc\n"; /**< Логирует нажатие Esc. */
            keyProcessed = true; /**< Отмечает, что клавиша обработана. */
            break; /**< Завершает обработку Esc. */
        case 'a': /**< Проверяет нажатие клавиши 'a'. */
            keyStates['a'] = true; /**< Устанавливает состояние клавиши 'a' как нажатое. */
            keyStates[KEY_LEFT] = false; /**< Сбрасывает состояние стрелки влево, чтобы избежать конфликта. */
            player->setMoveLeft(true); /**< Включает движение игрока влево. */
            debugLog << "[" << getCurrentTime() << "] Движение влево (a)\n"; /**< Логирует начало движения влево. */
            keyProcessed = true; /**< Отмечает, что клавиша обработана. */
            break; /**< Завершает обработку 'a'. */
        case KEY_LEFT: /**< Проверяет нажатие стрелки влево. */
            keyStates[KEY_LEFT] = true; /**< Устанавливает состояние стрелки влево как нажатое. */
            keyStates['a'] = false; /**< Сбрасывает состояние 'a', чтобы избежать конфликта. */
            player->setMoveLeft(true); /**< Включает движение игрока влево. */
            debugLog << "[" << getCurrentTime() << "] Движение влево (KEY_LEFT)\n"; /**< Логирует начало движения влево. */
            keyProcessed = true; /**< Отмечает, что клавиша обработана. */
            break; /**< Завершает обработку стрелки влево. */
        case 'd': /**< Проверяет нажатие клавиши 'd'. */
            keyStates['d'] = true; /**< Устанавливает состояние клавиши 'd' как нажатое. */
            keyStates[KEY_RIGHT] = false; /**< Сбрасывает состояние стрелки вправо, чтобы избежать конфликта. */
            player->setMoveRight(true); /**< Включает движение игрока вправо. */
            debugLog << "[" << getCurrentTime() << "] Движение вправо (d)\n"; /**< Логирует начало движения вправо. */
            keyProcessed = true; /**< Отмечает, что клавиша обработана. */
            break; /**< Завершает обработку 'd'. */
        case KEY_RIGHT: /**< Проверяет нажатие стрелки вправо. */
            keyStates[KEY_RIGHT] = true; /**< Устанавливает состояние стрелки вправо как нажатое. */
            keyStates['d'] = false; /**< Сбрасывает состояние 'd', чтобы избежать конфликта. */
            player->setMoveRight(true); /**< Включает движение игрока вправо. */
            debugLog << "[" << getCurrentTime() << "] Движение вправо (KEY_RIGHT)\n"; /**< Логирует начало движения вправо. */
            keyProcessed = true; /**< Отмечает, что клавиша обработана. */
            break; /**< Завершает обработку стрелки вправо. */
        case 'w': /**< Проверяет нажатие клавиши 'w'. */
        case 32: /**< Проверяет нажатие пробела (код 32). */
        case KEY_UP: /**< Проверяет нажатие стрелки вверх. */
            player->setJump(true); /**< Запрашивает прыжок для игрока. */
            debugLog << "[" << getCurrentTime() << "] Прыжок\n"; /**< Логирует запрос на прыжок. */
            keyProcessed = true; /**< Отмечает, что клавиша обработана. */
            break; /**< Завершает обработку прыжка. */
        case 's': /**< Проверяет нажатие клавиши 's'. */
            debugLog << "[" << getCurrentTime() << "] Движение вниз (или приседание)\n"; /**< Логирует нажатие 's' (функционал не реализован). */
            keyProcessed = true; /**< Отмечает, что клавиша обработана. */
            break; /**< Завершает обработку 's'. */
        default: /**< Обрабатывает необработанные клавиши. */
            debugLog << "[" << getCurrentTime() << "] Необработанная клавиша: " << key << "\n"; /**< Логирует код необработанной клавиши. */
            keyProcessed = false; /**< Отмечает, что клавиша не обработана. */
            break; /**< Завершает обработку по умолчанию. */
    } /**< Завершает switch-блок обработки клавиш. */

    if (keyProcessed) { /**< Проверяет, была ли клавиша обработана. */
        if (prevLeft && key != 'a' && key != KEY_LEFT) { /**< Проверяет, нужно ли остановить движение влево. */
            keyStates['a'] = false; /**< Сбрасывает состояние клавиши 'a'. */
            keyStates[KEY_LEFT] = false; /**< Сбрасывает состояние стрелки влево. */
            player->setMoveLeft(false); /**< Отключает движение игрока влево. */
            debugLog << "[" << getCurrentTime() << "] Движение влево остановлено\n"; /**< Логирует остановку движения влево. */
        } /**< Завершает обработку остановки движения влево. */
        if (prevRight && key != 'd' && key != KEY_RIGHT) { /**< Проверяет, нужно ли остановить движение вправо. */
            keyStates['d'] = false; /**< Сбрасывает состояние клавиши 'd'. */
            keyStates[KEY_RIGHT] = false; /**< Сбрасывает состояние клавиши стрелки вправо. */
            player->setMoveRight(false); /**< Отключает движение игрока вправо. */
            debugLog << "[" << getCurrentTime() << "] Движение вправо остановлено\n"; /**< Логирует остановку движения вправо. */
        } /**< Завершает обработку остановки движения вправо. */
    } /**< Завершает обработку обработанных клавиш. */

    debugLog << "[" << getCurrentTime() << "] keyStates: a=" << keyStates['a'] << ", d=" << keyStates['d'] 
             << ", left=" << keyStates[KEY_LEFT] << ", right=" << keyStates[KEY_RIGHT] << "\n"; /**< Логирует текущее состояние клавиш. */
} /**< Завершает метод handleInput. */

/** @brief Рендерит игровую сцену, включая уровень, игрока, врагов и интерфейс.
 * @author H0ly
 */
void Game::render() { /**< Объявляет метод рендеринга сцены. */
    clear(); /**< Очищает экран консоли перед отрисовкой. */

    cameraX = static_cast<int>(player->getX()) - screenWidth / 2; /**< Вычисляет позицию камеры по X, центрируя на игроке. */
    cameraY = static_cast<int>(player->getY()) - screenHeight / 2; /**< Вычисляет позицию камеры по Y, центрируя на игроке. */

    if (level->getWidth() <= screenWidth) { /**< Проверяет, меньше ли ширина уровня ширины экрана. */
        cameraX = (level->getWidth() - screenWidth) / 2; /**< Центрирует камеру по X, если уровень мал. */
    } else { /**< Обрабатывает случай, когда уровень шире экрана. */
        cameraX = std::max(0, std::min(cameraX, level->getWidth() - screenWidth)); /**< Ограничивает позицию камеры по X в пределах уровня. */
    } /**< Завершает настройку позиции камеры по X. */
    if (level->getHeight() <= screenHeight) { /**< Проверяет, меньше ли высота уровня высоты экрана. */
        cameraY = (level->getHeight() - screenHeight) / 2; /**< Центрирует камеру по Y, если уровень мал. */
    } else { /**< Обрабатывает случай, когда уровень выше экрана. */
        cameraY = std::max(0, std::min(cameraY, level->getHeight() - screenHeight)); /**< Ограничивает позицию камеры по Y в пределах уровня. */
    } /**< Завершает настройку позиции камеры по Y. */

    debugLog << "[" << getCurrentTime() << "] Позиция камеры: x=" << cameraX << "\ty=" << cameraY << "\n"; /**< Логирует текущую позицию камеры. */

    for (int y = 0; y < screenHeight; ++y) { /**< Перебирает строки экрана для рендеринга. */
        for (int x = 0; x < screenWidth; ++x) { /**< Перебирает столбцы экрана для рендеринга. */
            int mapX = x + cameraX; /**< Вычисляет координату X на карте с учётом смещения камеры. */
            int mapY = y + cameraY; /**< Вычисляет координату Y на карте с учётом смещения камеры. */
            if (mapX >= 0 && mapX < level->getWidth() && mapY >= 0 && mapY < level->getHeight()) { /**< Проверяет, находится ли координата в пределах уровня. */
                TileType tile = level->getTile(mapX, mapY); /**< Получает тип клетки на карте. */
                if (tile == TileType::WALL) { /**< Проверяет, является ли клетка стеной. */
                    attron(COLOR_PAIR(1)); /**< Включает цветовую пару для стен (белый на чёрном). */
                    mvaddch(y, x, '#'); /**< Отрисовывает символ стены '#' в позиции (y, x). */
                    attroff(COLOR_PAIR(1)); /**< Выключает цветовую пару для стен. */
                } else if (tile == TileType::COIN) { /**< Проверяет, является ли клетка монетой. */
                    attron(COLOR_PAIR(2)); /**< Включает цветовую пару для монет (жёлтый на чёрном). */
                    mvaddch(y, x, 'C'); /**< Отрисовывает символ монеты 'C' в позиции (y, x). */
                    attroff(COLOR_PAIR(2)); /**< Выключает цветовую пару для монет. */
                } else if (tile == TileType::FINISH) { /**< Проверяет, является ли клетка финишем. */
                    attron(COLOR_PAIR(3)); /**< Включает цветовую пару для финиша (зелёный на чёрном). */
                    mvaddch(y, x, '+'); /**< Отрисовывает символ финиша '+' в позиции (y, x). */
                    attroff(COLOR_PAIR(3)); /**< Выключает цветовую пару для финиша. */
                } else if (tile == TileType::SPIKES) { /**< Проверяет, является ли клетка шипами. */
                    attron(COLOR_PAIR(6)); /**< Включает цветовую пару для шипов (пурпурный на чёрном). */
                    mvaddch(y, x, 'S'); /**< Отрисовывает символ шипов '^' в позиции (y, x). */
                    attroff(COLOR_PAIR(6)); /**< Выключает цветовую пару для шипов. */
                } /**< Завершает обработку типа клетки. */
            } /**< Завершает проверку координат карты. */
        } /**< Завершает цикл по столбцам экрана. */
    } /**< Завершает цикл по строкам экрана. */

    int playerScreenX = static_cast<int>(player->getX()) - cameraX; /**< Вычисляет экранную координату X игрока с учётом камеры. */
    int playerScreenY = static_cast<int>(player->getY()) - cameraY; /**< Вычисляет экранную координату Y игрока с учётом камеры. */
    if (playerScreenX >= 0 && playerScreenX < screenWidth && playerScreenY >= 0 && playerScreenY < screenHeight) { /**< Проверяет, находится ли игрок в пределах экрана. */
        attron(COLOR_PAIR(4)); /**< Включает цветовую пару для игрока (голубой на чёрном). */
        mvaddch(playerScreenY, playerScreenX, player->getSymbol()); /**< Отрисовывает символ игрока в его экранной позиции. */
        attroff(COLOR_PAIR(4)); /**< Выключает цветовую пару для игрока. */
    } /**< Завершает рендеринг игрока. */

    for (const auto& enemy : enemies) { /**< Перебирает всех врагов для рендеринга. */
        int enemyScreenX = static_cast<int>(enemy->getX()) - cameraX; /**< Вычисляет экранную координату X врага. */
        int enemyScreenY = static_cast<int>(enemy->getY()) - cameraY; /**< Вычисляет экранную координату Y врага. */
        if (enemyScreenX >= 0 && enemyScreenX < screenWidth && enemyScreenY >= 0 && enemyScreenY < screenHeight) { /**< Проверяет, находится ли враг в пределах экрана. */
            attron(COLOR_PAIR(5)); /**< Включает цветовую пару для врагов (красный на чёрном). */
            mvaddch(enemyScreenY, enemyScreenX, enemy->getSymbol()); /**< Отрисовывает символ врага в его экранной позиции. */
            attroff(COLOR_PAIR(5)); /**< Выключает цветовую пару для врагов. */
        } /**< Завершает рендеринг одного врага. */
    } /**< Завершает цикл рендеринга врагов. */

    mvprintw(0, 0, "Score: %d", player->getScore()); /**< Выводит текущий счёт игрока в левом верхнем углу. */
    mvprintw(1, 0, "Lives: %d", player->getLives()); /**< Выводит количество жизней игрока под счётом. */

    refresh(); /**< Обновляет экран, применяя все изменения. */
} /**< Завершает метод render. */